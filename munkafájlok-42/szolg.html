<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="styles.css">
<title>Izzó Fitnesz Klub</title>
</head>
<body>
    <div id="oldal">
        <div id="fejlec">
            <h1>programozási nyelvek</h1>
            <h2>készitette: Patrik, Gergő, Dominik </h2>
        </div>
        <div id="menu">
            <ul>
                <li><a href="index.html" class="kivalasztott">C++</a></li>
                <li><a href="szolg.html" class="kivalasztott">C</a></li>
                <li><a href="kapcs.html" class="kivalasztott">C#</a></li>
                <li><a href="java.html" class="kivalasztott">Java</a></li>
            </ul>
        </div>
        <div id="tartalom">
            <h1>C programozási nyelv</h1>
            <p class="kep"><img src="c-programming.png"></p>
            <b> programozási nyelv a számítástechnikában használt olyan, ember által is értelmezhető utasítások sorozata, amivel közvetlenül, vagy közvetve (például: gépi kódra fordítás után) közölhetjük a számítógéppel egy adott feladat elvégzésének módját.Az informatikában a programozási nyelv egy ember által is olvasható és értelmezhető nyelv, amin a számítógép (vagy más eszköz, például mobiltelefon) számára írnak utasításokat.

                Amikor egy szoftvert, például egy képszerkesztő programot használsz, akkor a gép azért tudja, hogy mit kell csinálnia, mert mások azt a korábban egy programozási nyelv használatával megírták számára.</b></p>
            <p style="color: white ;"><i>Ismerd meg a programozás nyelveit! :)</i></p>
          
            
<table>
                <tbody>
                <tr>
                <th>Verziószám</th>
                <th>Megjelenés</th>
                <th>Főbb újdonságok
                </th></tr>
                <tr>
                <td>2.0</td>
                <td>2005. november</td>
                <td>Generikus és parciális típusok, anonim metódusok, iterátorok
                </td></tr>
                <tr>
                <td>3.0</td>
                <td>2006. november</td>
                <td>Implicit módon megadott lokális változók, lambda-, és lekérdezés-kifejezések, kifejezésfák, objektuminicializálók
                </td></tr>
                <tr>
                <td>3.0</td>
                <td>2007. november</td>
                <td>Language Integrated Query, lambda-kifejezések, kiegészítő metódusok
                </td></tr>
                <tr>
                <td>4.0</td>
                <td>2010. április</td>
                <td>Dinamikus kötés, opcionális paraméterek, generikus ko- és kontravariancia, Párhuzamos programozás támogatás, PLINQ
                </td></tr>
                <tr>
                <td>5.0</td>
                <td>2012. augusztus</td>
                <td>Aszinkron feladatok, párhuzamos programozás továbbfejlesztése
                </td></tr>
                <tr>
                <td>6.0</td>
                <td>2015. július</td>
                <td>Null kondicionális operátor, statikus importálás, csak olvasható auto tulajdonságok
                </td></tr>
                <tr>
                <td>7.0
                </td>
                <td>2017. március
                </td>
                <td>Out változók, Tuple típus, Pattern matching, helyi metódusok, throw kifejezések
                </td></tr>
                <tr>
                <td>7.1
                </td>
                <td>2017. augusztus
                </td>
                <td>aszinkron Main metódus
                </td></tr>
                <tr>
                <td>7.2
                </td>
                <td>2017. november
                </td>
                <td>private protected hozzáférési szint, számok tagolásához használható a _ karakter
                </td></tr>
                <tr>
                <td>7.3
                </td>
                <td>2018. május
                </td>
                <td>stackalloc tömb inicializáció
                </td></tr>
                <tr>
                <td>8.0
                </td>
                <td>2019. szeptember
                </td>
                <td>Nullable referencia típusok
                </td></tr>
                <tr>
                <td>9.0
                </td>
                <td>2020. szeptember
                </td>
                <td>Rekordtípusok, init only setterek, mintaillesztés, kódgenerátor<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"></a></sup>
                </td></tr></tbody></table>
                <br></br>
                


                <p style="text-align: left;">
                    <h3>  <br>A C# az a programozási nyelv</br> </h3>
        ami a legközvetlenebb módon tükrözi az alatta működő, minden .NET programot futtató .NET keretrendszert, valamint erősen függ is attól: nincsen nem menedzselt, natív módban futó C# program. A primitív adattípusai objektumok, a .NET típusok megfelelői. Szemétgyűjtést használ, valamint az absztrakcióinak többsége (osztályok, interfészek, delegáltak, kivételek…) a .NET futtatórendszert használja közvetlen módon.
                    A C vagy C++ nyelvhez hasonlítva a C# több korlátozást és továbbfejlesztést is tartalmaz.
        <br></br>
                    <b>  A lehetőségei közül néhány:</b>

                        A mutatók és a nem ellenőrzött aritmetika csak egy speciális, nem biztonságos módban (unsafe mode) használható. A legtöbb objektum-hozzáférés csak biztonságos hivatkozásokon keresztül tehető meg, és az aritmetikai műveletek debug módban túlcsordulás szempontjából ellenőrzöttek.
                        Az objektumok nem szabadíthatók fel közvetlen módon, ehelyett a szemétgyűjtő szabadítja fel őket, mikor már nincs rájuk hivatkozás. Ez a módszer kizárja a nem létező objektumokra való hivatkozás lehetőségét.
                        A destruktorok (~) elérhetőek. A megfelelően megírt IDisposable interfész (Disposable programozási minta), aminek a lefutását garantálja using blokk, együtt kikényszerítheti az azonnali felszabadítást az osztályon belüli natív erőforrások esetében. A nem natív erőforrások felszabadítását ebben az esetben is a szemétgyűjtő (Garbage Collector) végzi. A finalizerek szintén rendelkezésre állnak, de nem váltanak ki azonnali felszabadítást. Finalizer a Dispose eljárás javasolt implementációs módozatában nem fut le, mivel az ajánlás szerint a szemétgyűjtőt utasítani kell a finalizer hívás kihagyására.
                        A nyelv csak egyszeres öröklődést támogat, de egy osztály több interfészt is megvalósíthat.
                        A C# sokkal típusbiztosabb, mint a C++. Az egyetlen implicit konverzió a biztonságos konverzió, úgy mint az egészek tágabb intervallumba konvertálása vagy a leszármazott osztályok alaposztályba konvertálása. Nincs implicit konverzió az egészek és a logikai típus (boolean) között, a felsorolás tagok és az egészek között. Nincsenek void mutatók (bár az Object osztályra mutató mutatók hasonlóak), valamint bármely, a felhasználó által definiált implicit konverziót explicit módon meg kell jelölni.
                        A felsorolás adattagjai a saját névterükben helyezkednek el.
                        A 2.0-s verziótól felfelé már rendelkezik a generikus programozás néhány eszközével.
                        Tulajdonságok (Properties) használhatók, amelyek úgy tesznek lehetővé kódfuttatást mezők beállításakor és olvasásakor, hogy közben az adattagok szintaxisát használja.
                    <br></br>
                
            <h3><br> Összehasonlítás a Javával</br></h3>
                    
                    A Microsoft bár úgy fejlesztette ezt a nyelvet, mint a saját Java implementációját, bizonyos tulajdonságokban azonban eltérő szemléletmódot követ a két rendszer. Ilyen különbségek például:
                    
                        A Java alapértelmezett láthatósága mindig csomagon (package) belül publikus, a C#-nál mindig privát, a protected jelentése eltér, illetve támogatja az internal és a protected internal láthatóságot
                        A C# támogatja a parciális osztályokat (2.0-s verziótól felfelé), és az operátor-felüldefiniálást (en:Operator Overloading)
                        A metódusok a Javában alapból virtuálisak, ellentétben a C#-pal
                        A Java ellenben például lehetővé teszi a fordításidejű kivételkezelést
                        A Java támogatja az egzisztenciális generikusokat, míg a C# a ko- és kontravarianciát (4.0-s verziótól) a generikusoknál
                        A C# támogatja az azonos nevű, de eltérő verziójú szerelvények betöltését, ezzel szemben a Java-ban nincs ilyen támogatás
                        Java esetén nincsenek tulajdonságok, amelyek megkönnyítenék az objektumok belső változóinak az ellenőrzött lekérését és módosítását. Helyette ez a funkció Getter és Setter metódusokkal van megvalósítva.
                        A C# támogatja a delegált metódusokat, amely hasonló funkciót valósít meg, mint C++ esetén a függvény mutatók.
                        A C# a delegált metódusoknak köszönhetően támogatja az eseménykezelést
                        A C# esetén van unsafe (nem biztonságos) kontextus, amelyben létezik mutató típus. (optimalizációt segíti)
                        A C# esetén van unchecked (nem ellenőrzött) kontextus, amiben a változók túlcsordulása és helyes típus konvertálása felülbírálható (optimalizációt segíti)
                    
                    Szintaxisban a két nyelv ugyanabba a nyelvcsaládba (C/C++ alapú nyelvek) tartozik, tehát mindkettőre a kapcsos zárójeles tagolás, sor végi pontosvessző a jellemző, ezért a kód nagyban hasonlít. </p>
        </div>

        </div>
    </div>
</body>
</html>